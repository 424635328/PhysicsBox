<!DOCTYPE html>
<html lang="zh-CN">
    <head>
        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <title>PhysicsLab Ultra - Final Fix</title>
        <style>
    :root {
        --box-size: 700px;
        --primary-text: #e0e0e0; --secondary-text: #b0b0b0; --background-main: #1a1a1a; --background-panel: #2c2c2c;
        --border-color: #555; --accent-color: #03a9f4; --tool-active-color: #ffab40; --challenge-color: #4caf50;
        --toast-success-bg: rgba(76, 175, 80, 0.9); --toast-error-bg: rgba(211, 47, 47, 0.9); --toast-info-bg: rgba(3, 169, 244, 0.9);
        /* NEW: Colors for new shapes and tools */
        --teleporter-a-color: #9c27b0; --teleporter-b-color: #ffeb3b; --gravity-zone-color: rgba(76, 175, 80, 0.25);
        --vortex-color: rgba(103, 58, 183, 0.5);
    }
    body {
        font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif; margin: 0; display: flex; flex-direction: column; justify-content: center; align-items: center; min-height: 100vh;
        background: linear-gradient(45deg, #121212, #242424, #121212); background-size: 400% 400%; animation: gradientBG 15s ease infinite;
        overflow: hidden; color: var(--primary-text);
    }
    @keyframes gradientBG { 0% { background-position: 0% 50%; } 50% { background-position: 100% 50%; } 100% { background-position: 0% 50%; } }
    
    #main-layout { display: grid; grid-template-columns: 220px 1fr 220px; align-items: flex-start; gap: 30px; padding: 20px; width: 100%; max-width: 1400px; box-sizing: border-box; }
    #left-panel, #right-panel { display: flex; flex-direction: column; gap: 20px; }
    #center-content { display: flex; justify-content: center; }
    
    #physics-container { width: var(--box-size); height: var(--box-size); border: 3px solid var(--border-color); position: relative; box-shadow: 0 0 20px rgba(0,0,0,0.5); transition: transform 0.3s cubic-bezier(0.25, 1, 0.5, 1), width 0.3s ease, height 0.3s ease; touch-action: none; }
    canvas { display: block; width: 100%; height: 100%; }

    .control-group { background: var(--background-panel); padding: 15px; border-radius: 8px; border: 1px solid var(--border-color); }
    .control-group h3 { margin: 0 0 15px 0; text-align: center; color: var(--accent-color); border-bottom: 1px solid var(--border-color); padding-bottom: 10px; }
    #tool-buttons, #shape-buttons { grid-template-columns: repeat(auto-fit, minmax(60px, 1fr)); }
    .grid-buttons { display: grid; grid-template-columns: repeat(3, 1fr); gap: 10px; }
    #main-layout .grid-buttons { grid-template-columns: repeat(2, 1fr); }
    #tool-buttons { grid-template-columns: repeat(3, 1fr); }
    button, select { background: #424242; color: var(--primary-text); border: 2px solid var(--border-color); border-radius: 5px; padding: 10px; cursor: pointer; font-size: 14px; transition: all 0.2s ease; width: 100%; box-sizing: border-box; }
    button:hover, select:hover { border-color: var(--accent-color); background: #555; }
    #tool-buttons button.active, #shape-buttons button.active { border-color: var(--tool-active-color); background: #616161; box-shadow: 0 0 8px var(--tool-active-color); transform: scale(1.05); }
    #app-actions-group .grid-buttons button { font-size: 16px; }
    #challenge-description { font-size: 12px; color: var(--secondary-text); margin-top: 10px; min-height: 40px; }
    #win-message { display: none; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); padding: 20px 40px; background: rgba(76, 175, 80, 0.9); color: white; border-radius: 10px; font-size: 32px; font-weight: bold; z-index: 500; }
    #settings-panel { display: none; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); width: 500px; background: var(--background-panel); padding: 20px; border-radius: 10px; z-index: 200; box-shadow: 0 10px 30px rgba(0,0,0,0.5); border: 1px solid var(--border-color); max-height: 90vh; overflow-y: auto; }
    #settings-panel h2 { margin-top: 0; color: var(--accent-color); }
    .slider-group { margin-bottom: 15px; }
    .slider-group label { display: block; margin-bottom: 5px; font-size: 14px; }
    .slider-group input[type="range"] { width: 100%; }
    #close-settings-btn, #close-help-btn { position: absolute; top: 15px; right: 20px; font-size: 24px; background: none; border: none; color: #fff; cursor: pointer; }
    .settings-row { display: flex; flex-wrap: wrap; justify-content: space-between; align-items: center; margin-bottom: 15px; gap: 10px; }
    .btn { padding: 8px 12px; border-radius: 5px; border: none; cursor: pointer; }
    .btn-primary { background-color: var(--accent-color); color: white; }
    .btn-danger { background-color: #d32f2f; color: white; }
    #scene-management-buttons button, #scene-file-buttons .btn { flex-grow: 1; text-align: center; }
    #toast-container { position: fixed; top: 20px; right: 20px; z-index: 9999; display: flex; flex-direction: column; gap: 10px; pointer-events: none;}
    .toast { padding: 15px 20px; color: white; border-radius: 5px; font-size: 14px; opacity: 0; transform: translateX(100%); animation: slideIn 0.5s forwards; }
    @keyframes slideOut { to { opacity: 0; transform: translateX(100%); } }
    .toast.success { background-color: var(--toast-success-bg); } .toast.error { background-color: var(--toast-error-bg); } .toast.info { background-color: var(--toast-info-bg); }
    @keyframes slideIn { to { opacity: 1; transform: translateX(0); } }
    #help-panel-overlay { display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0, 0, 0, 0.85); z-index: 1500; justify-content: center; align-items: center; }
    #help-panel { position: relative; background: var(--background-panel); padding: 20px 30px; border-radius: 10px; width: 90%; max-width: 800px; max-height: 90vh; overflow-y: auto; }
    #help-panel h3 { color: var(--accent-color); } #help-panel ul { padding-left: 20px; } #help-panel li { margin-bottom: 10px; } #help-panel code { background-color: #424242; padding: 2px 6px; border-radius: 4px; font-family: monospace; }
    </style>
    </head>
    <body>
        <div id="toast-container"></div>

        <div id="main-layout">
            <div id="left-panel">
                <div class="control-group">
                    <h3>å·¥å…· (Tool)</h3>
                    <div id="tool-buttons" class="grid-buttons">
                        <button class="tool-btn active" data-tool="add"
                            title="æ·»åŠ /æ‹–æ‹½ (Add/Drag)">æ‹–æ‹½</button>
                        <button class="tool-btn" data-tool="remove"
                            title="ç§»é™¤ (Remove)">ç§»é™¤</button>
                        <button class="tool-btn" data-tool="pin"
                            title="å›ºå®š/å–æ¶ˆå›ºå®š (Pin)">å›ºå®š</button>
                        <button class="tool-btn" data-tool="link"
                            title="è¿æ¥ä¸¤ä¸ªç‰©ä½“ (Link)">è¿æ¥</button>
                        <button class="tool-btn" data-tool="motor"
                            title="æ·»åŠ ç”µæœº (Motor)">ç”µæœº</button>
                        <button class="tool-btn" data-tool="push"
                            title="ç‚¹å‡»å¹¶æ‹–æ‹½ä»¥æ–½åŠ åŠ› (Push)">æ¨åŠ¨</button>
                        <button class="tool-btn" data-tool="pen"
                            title="ç»˜åˆ¶é™æ€å¢™å£ (Pen)">ç”»ç¬”</button>
                        <button class="tool-btn" data-tool="eraser"
                            title="æ“¦é™¤ç”»ç¬”å¢™å£ (Eraser)">æ©¡çš®</button>
                        <button class="tool-btn" data-tool="scale"
                            title="æ»šè½®ç¼©æ”¾ç‰©ä½“ (Scale)">ç¼©æ”¾</button>
                        <button class="tool-btn" data-tool="tuner"
                            title="è°ƒæ•´ç‰©ä½“å±æ€§ (Tuner)">è°ƒæ•´</button>
                    </div>
                </div>
                <div class="control-group">
                    <h3>å½¢çŠ¶ (Shape)</h3>
                    <div id="shape-buttons" class="grid-buttons">
                        <button class="shape-btn active"
                            data-shape="box">æ–¹å—</button>
                        <button class="shape-btn"
                            data-shape="circle">åœ†å½¢</button>
                        <button class="shape-btn"
                            data-shape="polygon">å¤šè¾¹å½¢</button>
                        <button class="shape-btn"
                            data-shape="trapezoid">æ¢¯å½¢</button>
                        <button class="shape-btn" data-shape="bomb">ç‚¸å¼¹</button>
                        <button class="shape-btn" data-shape="soft">æŸ”æ€§ä½“</button>
                        <button class="shape-btn" data-shape="platform"
                            title="å·¦é”®æ¨ªæ”¾, å³é”®ç«–æ”¾">å¹³å°</button>
                        <button class="shape-btn" data-shape="gear"
                            title="åˆ›å»ºä¸€ä¸ªé½¿è½®">é½¿è½®</button>
                        <button class="shape-btn" data-shape="thruster"
                            title="åˆ›å»ºæ¨è¿›å™¨, å³é”®å¼€å…³">æ¨è¿›å™¨</button>
                        <button class="shape-btn" data-shape="attractor"
                            title="åˆ›å»ºå¼•åŠ›æº">å¼•åŠ›æº</button>
                        <button class="shape-btn" data-shape="teleporter"
                            title="ä¾æ¬¡ç‚¹å‡»åˆ›å»ºæˆå¯¹çš„ä¼ é€é—¨">ä¼ é€é—¨</button>
                        <button class="shape-btn" data-shape="gravityZone"
                            title="åˆ›å»ºåé‡åŠ›åŒºåŸŸ">åé‡åŠ›åœº</button>
                        <button class="shape-btn" data-shape="vortex"
                            title="åˆ›å»ºæ¼©æ¶¡ï¼Œå¸å…¥å¹¶æ—‹è½¬ç‰©ä½“">æ¼©æ¶¡</button>
                    </div>
                </div>
            </div>

            <div id="center-content">
                <div id="physics-container">
                    <div id="win-message">æŒ‘æˆ˜æˆåŠŸ!</div>
                </div>
            </div>

            <div id="right-panel">
                <div id="app-actions-group" class="control-group">
                    <h3>æ“ä½œ</h3>
                    <div class="grid-buttons">
                        <button id="settings-btn" title="æ‰“å¼€é«˜çº§è®¾ç½®">é«˜çº§è®¾ç½®
                            âš™ï¸</button>
                        <button id="help-btn" title="æ‰“å¼€å¸®åŠ©è¯´æ˜">å¸®åŠ©è¯´æ˜ â“</button>
                    </div>
                </div>
                <div class="control-group">
                    <h3>æŒ‘æˆ˜ (Challenges)</h3>
                    <label for="challenge-select">å¼€å§‹ä¸€ä¸ªæŒ‘æˆ˜:</label>
                    <select id="challenge-select">
                        <option value>-- è‡ªç”±æ¨¡å¼ --</option>
                    </select>
                    <p id="challenge-description">æ¬¢è¿ï¼è¿™é‡Œæ˜¯è‡ªç”±æ²™ç›’æ¨¡å¼ã€‚å°½æƒ…åˆ›é€ å§ï¼</p>
                </div>
            </div>
        </div>

        <div id="settings-panel">
            <button id="close-settings-btn" title="å…³é—­">Ã—</button>
            <h2>é«˜çº§è®¾ç½®</h2>
            <div class="control-group">
                <h3>åœºæ™¯ç®¡ç† (æš‚ä¸å¯ç”¨)</h3>
                <p
                    style="font-size:12px; color: var(--secondary-text);">åœºæ™¯ç®¡ç†æš‚ä¸æ”¯æŒæ–°ç‰ˆå½¢çŠ¶(ç”»ç¬”/ä¼ é€é—¨ç­‰)ï¼Œæ­¤åŠŸèƒ½å¾…å¼€å‘ã€‚</p>
                <div class="settings-row" id="scene-management-buttons">
                    <button class="btn" id="save-browser-btn"
                        disabled>å­˜è‡³æµè§ˆå™¨</button>
                    <button class="btn" id="load-browser-btn"
                        disabled>ä»æµè§ˆå™¨è¯»</button>
                    <button class="btn btn-primary" id="share-scene-btn"
                        disabled>åˆ†äº«åœºæ™¯</button>
                </div>
                <div class="settings-row" id="scene-file-buttons">
                    <button class="btn" id="save-file-btn"
                        disabled>å­˜ä¸ºæ–‡ä»¶</button>
                    <label class="btn" for="load-file-input"
                        style="background-color:#555; cursor: not-allowed;">ä»æ–‡ä»¶è¯»</label>
                    <input type="file" id="load-file-input" accept=".json"
                        style="display:none;" disabled>
                </div>
            </div>
            <div class="control-group">
                <h3>ä¸–ç•Œè®¾ç½®</h3>
                <div class="slider-group">
                    <label>ç”»å¸ƒå¤§å°: <span id="box-size-value">700</span>px</label>
                    <input type="range" id="box-size-slider" min="400"
                        max="1000" step="10" value="700">
                </div>
                <div class="settings-row">
                    <label>æ—‹è½¬æ¨¡å¼:</label>
                    <select id="rotation-mode-select">
                        <option value="visual">è§†è§‰æ—‹è½¬</option>
                        <option value="gravity">ä»…é‡åŠ›</option>
                    </select>
                </div>
                <div class="slider-group">
                    <label>å…¨å±€é‡åŠ›: <span id="gravity-value">1.0</span></label>
                    <input type="range" id="gravity-slider" min="0" max="3"
                        step="0.1" value="1">
                </div>
                <div class="slider-group">
                    <label>å…¨å±€å¼¹åŠ›: <span id="restitution-value">0.1</span></label>
                    <input type="range" id="restitution-slider" min="0" max="1"
                        step="0.05" value="0.1">
                </div>
                <div class="slider-group">
                    <label>æ—¶é—´æµé€Ÿ: <span id="timescale-value">1.0</span></label>
                    <input type="range" id="timescale-slider" min="0.1" max="2"
                        step="0.1" value="1">
                </div>
            </div>
            <hr>
            <button id="clear-all-btn" class="btn btn-danger"
                style="width:100%;">æ¸…é™¤æ‰€æœ‰ç‰©ä½“</button>
        </div>

        <div id="help-panel-overlay">
            <div id="help-panel">
                <button id="close-help-btn">Ã—</button>
                <h2>ç©æ³•è¯´æ˜</h2>
                <h3>åŸºç¡€å·¥å…·</h3>
                <ul>
                    <li><b>æ·»åŠ /æ‹–æ‹½</b>: åœ¨ç”»å¸ƒç©ºç™½å¤„ <b>å•å‡»å·¦é”®</b> æ·»åŠ å½“å‰é€‰ä¸­çš„å½¢çŠ¶ã€‚<b>æŒ‰ä½å·¦é”®</b>
                        å¯æ‹–æ‹½å·²æœ‰ç‰©ä½“ã€‚</li>
                    <li><b>ç§»é™¤</b>: <b>å·¦é”®ç‚¹å‡»</b> ä»»ä½•ç‰©ä½“æˆ–è¿æ¥çº¿å¯å°†å…¶ç§»é™¤ã€‚</li>
                    <li><b>å›ºå®š</b>: <b>å·¦é”®ç‚¹å‡»</b> ç‰©ä½“å¯ä½¿å…¶å®Œå…¨å›ºå®šæˆ–å–æ¶ˆå›ºå®šã€‚</li>
                    <li><b>è¿æ¥</b>: ä¾æ¬¡ <b>å·¦é”®ç‚¹å‡»</b> ä¸¤ä¸ªç‰©ä½“æ¥åˆ›å»ºæŸ”æ€§è¿æ¥ã€‚</li>
                    <li><b>ç”µæœº</b>: <b>å·¦é”®ç‚¹å‡»</b> ç‰©ä½“æ·»åŠ é¡ºæ—¶é’ˆç”µæœºï¼Œ<b>å³é”®</b> æ·»åŠ é€†æ—¶é’ˆç”µæœºã€‚</li>
                    <li><b>æ¨åŠ¨</b>: åœ¨ç‰©ä½“ä¸Š <b>æŒ‰ä½å·¦é”®å¹¶æ‹–æ‹½</b> æ¥ç”»å‡ºä¸€ä¸ªåŠ›çš„çŸ¢é‡ï¼Œ<b>æ¾å¼€å·¦é”®</b>
                        æ–½åŠ æ¨åŠ›ã€‚</li>
                </ul>
                <h3>åˆ›æ„å·¥å…· & å½¢çŠ¶</h3>
                <ul>
                    <li><b>ç”»ç¬”</b>: <b>æŒ‰ä½å·¦é”®æ‹–æ‹½</b> æ¥ç»˜åˆ¶è‡ªå®šä¹‰çš„é™æ€å¢™å£ã€‚</li>
                    <li><b>æ©¡çš®</b>: <b>å·¦é”®ç‚¹å‡»</b> ç”±ç”»ç¬”ç»˜åˆ¶çš„å¢™å£æ¥æ“¦é™¤å®ƒã€‚</li>
                    <li><b>ç¼©æ”¾</b>: å°†é¼ æ ‡æ‚¬åœåœ¨ç‰©ä½“ä¸Šï¼Œä½¿ç”¨ <b>é¼ æ ‡æ»šè½®</b> æ”¾å¤§æˆ–ç¼©å°å®ƒã€‚</li>
                    <li><b>è°ƒæ•´</b>: <b>å·¦é”®ç‚¹å‡»</b> ç‰©ä½“å¢åŠ å…¶å¼¹åŠ›ï¼Œ<b>å³é”®ç‚¹å‡»</b> å‡å°‘å…¶å¼¹åŠ›ã€‚</li>
                    <li><b>å¹³å°</b>: åˆ›å»ºæ—¶ï¼Œ<b>å·¦é”®</b> ä¸ºæ¨ªå‘ï¼Œ<b>å³é”®</b> ä¸ºç«–å‘ã€‚</li>
                    <li><b>æ¨è¿›å™¨</b>: åˆ›å»ºåï¼Œç”¨ä»»æ„å·¥å…· <b>å³é”®ç‚¹å‡»</b> å¯å¼€å…³æ¨è¿›å™¨ã€‚</li>
                    <li><b>ä¼ é€é—¨</b>: <b>ä¾æ¬¡å·¦é”®ç‚¹å‡»ä¸¤æ¬¡</b> åˆ›å»ºä¸€å¯¹ä¼ é€é—¨ã€‚å³é”®å¯å–æ¶ˆç¬¬ä¸€æ¬¡é€‰æ‹©ã€‚</li>
                    <li><b>å¼•åŠ›æº / æ¼©æ¶¡</b>: åˆ›å»ºåï¼Œå®ƒä»¬ä¼šè‡ªåŠ¨å¯¹èŒƒå›´å†…çš„ç‰©ä½“æ–½åŠ åŠ›ã€‚</li>
                </ul>
                <h3>é€šç”¨æ“ä½œ & å¿«æ·é”®</h3>
                <ul>
                    <li><b>æ—‹è½¬ä¸–ç•Œ</b>: æŒ‰ä¸‹ <code>Q</code> / <code>E</code> é”®æˆ–
                        <code>â†</code> / <code>â†’</code> æ–¹å‘é”®ã€‚æŒ‰ä½
                        <code>Shift</code> å¯è¿›è¡Œ90åº¦æ—‹è½¬ã€‚</li>
                    <li><b>é€šç”¨å³é”®</b>: åœ¨éç‰¹æ®Šæ“ä½œä¸‹ï¼Œå³é”®å¯å–æ¶ˆâ€œè¿æ¥â€ã€â€œæ¨åŠ¨â€ã€â€œç”»ç¬”â€ç­‰æ“ä½œã€‚</li>
                    <li><code>P</code>: æ‹–æ‹½æ—¶**å›ºå®š (Pin)**ç‰©ä½“ã€‚</li>
                    <li><code>D</code>: æ‚¬åœæ—¶**åˆ é™¤ (Delete)**ç‰©ä½“ã€‚</li>
                    <li><code>R</code>: **é‡ç½® (Reset)**ä¸–ç•Œæ—‹è½¬å’Œé‡åŠ›ã€‚</li>
                    <li><code>C</code>: **æ¸…é™¤ (Clear)**æ‰€æœ‰ç‰©ä½“ (ä¼šå¼¹å‡ºç¡®è®¤æ¡†)ã€‚</li>
                    <li><code>ç©ºæ ¼é”®</code>: **æš‚åœ / ç»§ç»­**ç‰©ç†æ¨¡æ‹Ÿã€‚</li>
                </ul>
            </div>
        </div>

        <script
            src="https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.19.0/matter.min.js"></script>
        <script>
    document.addEventListener('DOMContentLoaded', () => {
        const PhysicsLab = {
            Engine: Matter.Engine, Render: Matter.Render, Runner: Matter.Runner, Bodies: Matter.Bodies, Composite: Matter.Composite,
            Mouse: Matter.Mouse, MouseConstraint: Matter.MouseConstraint, Query: Matter.Query, Events: Matter.Events, Body: Matter.Body,
            Constraint: Matter.Constraint, Composites: Matter.Composites, Vertices: Matter.Vertices, Bounds: Matter.Bounds,

            engine: null, world: null, render: null, runner: null, mouseConstraint: null,
            linkFirstBody: null, worldAngle: 0,
            BOX_CENTER: { x: 350, y: 350 },
            walls: [], isPaused: false,
            
            pushStartPos: null, pushEndPos: null, pushTargetBody: null,
            isDrawing: false, penPoints: [],
            teleporterLinkTarget: null,

            CONFIG: { version: "9.0-stable", currentTool: 'add', currentShape: 'box' },
            SETTINGS: { boxSize: 700, rotationMode: 'visual', gravityScale: 1.0, restitution: 0.1, timeScale: 1.0, motorSpeed: 0.2 },
            dom: {},

            init() { this.cacheDOMElements(); this.initEngine(); this.resize(this.SETTINGS.boxSize); this.initUI(); this.initEvents(); this.run(); },
            initEngine() { this.engine = this.Engine.create({ enableSleeping: true }); this.world = this.engine.world; this.render = this.Render.create({ element: this.dom.physicsContainer, engine: this.engine, options: { width: 700, height: 700, wireframes: false, background: 'transparent' }}); const mouse = this.Mouse.create(this.render.canvas); this.mouseConstraint = this.MouseConstraint.create(this.engine, { mouse: mouse, constraint: { stiffness: 0.2, render: { visible: false } }}); this.Composite.add(this.world, this.mouseConstraint); this.runner = this.Runner.create(); },
            resize(newSize) { this.SETTINGS.boxSize = newSize; this.BOX_CENTER = { x: newSize / 2, y: newSize / 2 }; document.documentElement.style.setProperty('--box-size', `${newSize}px`); this.render.bounds.max.x = newSize; this.render.bounds.max.y = newSize; this.render.options.width = newSize; this.render.options.height = newSize; this.render.canvas.width = newSize; this.render.canvas.height = newSize; if (this.walls.length > 0) { this.Composite.remove(this.world, this.walls); } const wallThickness = 50; const halfSize = newSize / 2; const wallOptions = { isStatic: true, label: 'wall', render: { visible: false } }; this.walls = [ this.Bodies.rectangle(halfSize, newSize + (wallThickness / 2), newSize + wallThickness, wallThickness, wallOptions), this.Bodies.rectangle(halfSize, -(wallThickness / 2), newSize + wallThickness, wallThickness, wallOptions), this.Bodies.rectangle(-(wallThickness / 2), halfSize, wallThickness, newSize + wallThickness, wallOptions), this.Bodies.rectangle(newSize + (wallThickness / 2), halfSize, wallThickness, newSize + wallThickness, wallOptions) ]; this.Composite.add(this.world, this.walls); if (this.dom.boxSizeValue) { this.dom.boxSizeValue.textContent = newSize; this.dom.sliders.box_size.value = newSize; } },
            run() { this.Render.run(this.render); this.Runner.run(this.runner, this.engine); this.updateVisualsAndGravity(); },
            
            createGearVertices(radius, teeth, toothHeight) { const vertices = []; const angleStep = (2 * Math.PI) / (teeth * 2); for (let i = 0; i < teeth * 2; i++) { const currentRadius = (i % 2 === 0) ? radius : radius - toothHeight; const angle = i * angleStep; vertices.push({ x: currentRadius * Math.cos(angle), y: currentRadius * Math.sin(angle) }); } return this.Vertices.create(vertices); },
            
            createShape(x, y, shapeType = this.CONFIG.currentShape, options = {}, playSound = true) {
                const size = this.SETTINGS.boxSize / 12;
                const defaultRender = { fillStyle: '#03a9f4', strokeStyle: '#e0e0e0', lineWidth: 0 };
                const bodyOptions = { restitution: this.SETTINGS.restitution, label: 'userBody', render: defaultRender, ...options };
                let body;
                switch (shapeType) {
                    case 'circle': body = this.Bodies.circle(x, y, size / 2, bodyOptions); break;
                    case 'polygon': body = this.Bodies.polygon(x, y, 5, size / 2, bodyOptions); break;
                    case 'trapezoid': body = this.Bodies.trapezoid(x, y, size, size * 0.7, 0.7, bodyOptions); break;
                    case 'bomb': body = this.Bodies.circle(x, y, size / 2, { ...bodyOptions, render: { fillStyle: '#212121', strokeStyle: '#ff5722', lineWidth: 3 }}); body.isBomb = true; body.explodeTime = Date.now() + 2000; if (playSound) setTimeout(() => this.explode(body), 2000); break;
                    case 'soft': body = this.createSoftBody({ x, y, columns: 5, rows: 5, columnGap: 5, rowGap: 5 }); this.Composite.add(this.world, body); break;
                    case 'platform': body = this.Bodies.rectangle(x, y, size * 2.5, size * 0.5, { ...bodyOptions, isStatic: true, render: { fillStyle: '#8d6e63' }}); break;
                    case 'gear': const gearParams = options.creationParams || { radius: size * 0.8, teeth: 8, toothHeight: size * 0.2 }; const gearVertices = this.createGearVertices(gearParams.radius, gearParams.teeth, gearParams.toothHeight); body = this.Bodies.fromVertices(x, y, [gearVertices], { ...bodyOptions, render: { fillStyle: '#78909c' }}, true); body.creationParams = gearParams; break;
                    case 'thruster': body = this.Bodies.trapezoid(x, y, size*0.8, size*0.8, 0.5, { ...bodyOptions, render: { fillStyle: '#607d8b', strokeStyle: '#cfd8dc', lineWidth: 2 }}); body.isThruster = true; body.isThrusterActive = false; body.thrustForce = 0.005; break;
                    case 'attractor': body = this.Bodies.circle(x, y, size / 3, { ...bodyOptions, isStatic: true, isSensor: true, render: { fillStyle: '#7e57c2', strokeStyle: '#ede7f6', lineWidth: 4 }}); body.isAttractor = true; body.attractionRadius = size * 5; body.attractionForce = 0.0005; break;
                    case 'vortex': body = this.Bodies.circle(x, y, size / 2.5, { ...bodyOptions, isStatic: true, isSensor: true, render: { fillStyle: getComputedStyle(document.documentElement).getPropertyValue('--vortex-color'), strokeStyle: '#d1c4e9', lineWidth: 2, }}); body.isVortex = true; body.vortexRadius = size * 6; body.vortexInwardForce = 0.0006; body.vortexTangentialForce = 0.00005; break;
                    case 'teleporter':
                        body = this.Bodies.circle(x, y, size / 3, { isStatic: true, isSensor: true, label: 'userBody' });
                        body.isTeleporter = true; body.linkedTeleporter = null;
                        if (!this.teleporterLinkTarget) {
                            this.teleporterLinkTarget = body; body.render.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--teleporter-a-color'); this.showToast('å…¥å£å·²åˆ›å»ºï¼Œè¯·åœ¨å¦ä¸€ä½ç½®åˆ›å»ºå‡ºå£', 'info');
                        } else {
                            body.linkedTeleporter = this.teleporterLinkTarget; this.teleporterLinkTarget.linkedTeleporter = body; body.render.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--teleporter-b-color'); this.showToast('ä¼ é€é—¨å·²é…å¯¹ï¼', 'success'); this.teleporterLinkTarget = null;
                        } break;
                    case 'gravityZone':
                        body = this.Bodies.rectangle(x, y, size * 3, size * 3, { isStatic: true, isSensor: true, label: 'userBody', render: { fillStyle: getComputedStyle(document.documentElement).getPropertyValue('--gravity-zone-color'), strokeStyle: '#fff', lineWidth: 1 }});
                        body.isGravityZone = true; break;
                    default: body = this.Bodies.rectangle(x, y, size, size, bodyOptions); break;
                }
                if (body && body.type !== 'composite') { body.shapeType = shapeType; this.Composite.add(this.world, body); }
                if (playSound && shapeType !== 'teleporter') this.showToast(`${shapeType} å·²æ·»åŠ `, 'info', 1000);
                return body;
            },
            createSoftBody(params) { const { x, y, columns, rows, columnGap, rowGap } = params; const softBody = this.Composites.stack(x - (columns * 10)/2, y - (rows * 10)/2, columns, rows, columnGap, rowGap, (px, py) => this.Bodies.circle(px, py, 5, { friction: 0.1, restitution: 0.4, render: {fillStyle: '#FDD835'}, label: 'userBody' })); this.Composites.mesh(softBody, columns, rows, false, { stiffness: 0.6, render: { type: 'line', visible: true, strokeStyle: 'rgba(255,255,255,0.5)' } }); softBody.shapeType = 'soft'; softBody.label = 'userBody'; softBody.creationParams = params; return softBody; },
            explode(bomb) { if (bomb.isExploded || !this.Composite.get(this.world, bomb.id, 'body')) return; bomb.isExploded = true; const pos = bomb.position; const radius = this.SETTINGS.boxSize / 4; this.removeBodyAndConstraints(bomb); const allBodies = this.Composite.allBodies(this.world); const affectedBodies = this.Query.region(allBodies, { min: { x: pos.x - radius, y: pos.y - radius }, max: { x: pos.x + radius, y: pos.y + radius } }); affectedBodies.forEach(body => { if (body.isStatic || body.isSensor) return; if (body.parent && body.parent.shapeType === 'soft') { if (!body.parent.isBeingRemoved) { body.parent.isBeingRemoved = true; this.removeBodyAndConstraints(body.parent); } } else { this.removeBodyAndConstraints(body); } }); this.showToast('ğŸ’¥ BOOM!', 'error'); },
            clearAll(quiet = false) { if (!quiet && !confirm('ä½ ç¡®å®šè¦æ¸…é™¤ç”»å¸ƒä¸Šæ‰€æœ‰çš„ç‰©ä½“å—ï¼Ÿæ­¤æ“ä½œæ— æ³•æ’¤é”€ã€‚')) return; this.Composite.clear(this.world, false); this.initEngine(); this.Runner.run(this.runner, this.engine); this.resize(this.SETTINGS.boxSize); this.teleporterLinkTarget = null; if (!quiet) this.showToast('å·²æ¸…ç©ºç”»å¸ƒ', 'info'); },
            removeBodyAndConstraints(body) {
                if (!body || !this.Composite.get(this.world, body.id, body.type)) return;
                const allConstraints = this.Composite.allConstraints(this.world);
                const bodyIds = (body.parts || [body]).map(p => p.id);
                const constraintsToRemove = allConstraints.filter(c => (c.bodyA && bodyIds.includes(c.bodyA.id)) || (c.bodyB && bodyIds.includes(c.bodyB.id)));
                constraintsToRemove.forEach(c => this.Composite.remove(this.world, c));
                this.Composite.remove(this.world, body);
            },
            cacheDOMElements() { const ids = [ 'physics-container', 'settings-panel', 'help-panel-overlay', 'help-panel', 'toast-container', 'tool-buttons', 'shape-buttons', 'challenge-select', 'challenge-description', 'win-message', 'settings-btn', 'help-btn', 'close-settings-btn', 'close-help-btn', 'save-browser-btn', 'load-browser-btn', 'share-scene-btn', 'save-file-btn', 'load-file-input', 'clear-all-btn', 'rotation-mode-select' ]; ids.forEach(id => { this.dom[id.replace(/-(\w)/g, (m, p1) => p1.toUpperCase())] = document.getElementById(id); }); const sliders = ['box-size', 'gravity', 'restitution', 'timescale']; this.dom.sliders = {}; this.dom.values = {}; sliders.forEach(s => { const id = s.replace(/-/g, '_'); this.dom.sliders[id] = document.getElementById(`${s}-slider`); this.dom.values[id] = document.getElementById(`${s}-value`); }); },
            initUI() { this.dom.toolButtons.addEventListener('click', e => { if (e.target.matches('button')) { this.setActiveTool(e.target.dataset.tool); }}); this.dom.shapeButtons.addEventListener('click', e => { if (e.target.matches('button')) { this.CONFIG.currentShape = e.target.dataset.shape; this.dom.shapeButtons.querySelector('.active').classList.remove('active'); e.target.classList.add('active'); this.teleporterLinkTarget = null; }}); this.dom.settingsBtn.onclick = () => this.dom.settingsPanel.style.display = 'block'; this.dom.closeSettingsBtn.onclick = () => this.dom.settingsPanel.style.display = 'none'; this.dom.helpBtn.onclick = () => this.dom.helpPanelOverlay.style.display = 'flex'; this.dom.closeHelpBtn.onclick = () => this.dom.helpPanelOverlay.style.display = 'none'; this.dom.clearAllBtn.onclick = () => this.clearAll(); this.dom.rotationModeSelect.onchange = e => { this.SETTINGS.rotationMode = e.target.value; this.updateVisualsAndGravity(); }; this.dom.sliders.box_size.addEventListener('input', e => { this.dom.values.box_size.textContent = e.target.value; }); this.dom.sliders.box_size.addEventListener('change', e => { this.resize(parseInt(e.target.value, 10)); }); for(const key in this.dom.sliders) { if (key !== 'box_size' && this.dom.sliders[key]) { this.dom.sliders[key].addEventListener('input', e => this.handleSliderInput(e, key)); } } this.updateUIFromConfig(); this.setActiveTool('add'); },
            setActiveTool(tool) { this.CONFIG.currentTool = tool; this.dom.toolButtons.querySelector('.active')?.classList.remove('active'); this.dom.toolButtons.querySelector(`[data-tool=${tool}]`).classList.add('active'); this.linkFirstBody = null; this.teleporterLinkTarget = null; this.isDrawing = false; this.penPoints = []; if (tool === 'add') { this.mouseConstraint.collisionFilter.mask = 0xFFFFFFFF; this.render.canvas.style.cursor = 'grab'; } else { this.mouseConstraint.collisionFilter.mask = 0x0000; this.render.canvas.style.cursor = 'crosshair'; } },
            updateUIFromConfig() { this.resize(this.SETTINGS.boxSize); this.dom.rotationModeSelect.value = this.SETTINGS.rotationMode; this.dom.sliders.gravity.value = this.SETTINGS.gravityScale; this.dom.values.gravity.textContent = this.SETTINGS.gravityScale.toFixed(1); this.dom.sliders.restitution.value = this.SETTINGS.restitution; this.dom.values.restitution.textContent = this.SETTINGS.restitution.toFixed(2); this.dom.sliders.timescale.value = this.SETTINGS.timeScale; this.dom.values.timescale.textContent = this.SETTINGS.timeScale.toFixed(1); this.engine.timing.timeScale = this.isPaused ? 0 : this.SETTINGS.timeScale; },
            updateVisualsAndGravity() { this.engine.gravity.x = this.SETTINGS.gravityScale * Math.sin(this.worldAngle); this.engine.gravity.y = this.SETTINGS.gravityScale * Math.cos(this.worldAngle); if (this.SETTINGS.rotationMode === 'visual') { this.dom.physicsContainer.style.transformOrigin = `${this.BOX_CENTER.x}px ${this.BOX_CENTER.y}px`; this.dom.physicsContainer.style.transform = `rotate(${this.worldAngle * (180 / Math.PI)}deg)`; } else { this.dom.physicsContainer.style.transformOrigin = 'center center'; this.dom.physicsContainer.style.transform = 'rotate(0deg)'; } },
            rotateWorld(angleChange) { const sin = Math.sin(angleChange); const cos = Math.cos(angleChange); const center = this.BOX_CENTER; const bodies = this.Composite.allBodies(this.world); bodies.forEach(body => { if (body.isStatic) return; const relPos = { x: body.position.x - center.x, y: body.position.y - center.y }; const newPos = { x: center.x + relPos.x * cos - relPos.y * sin, y: center.y + relPos.x * sin + relPos.y * cos }; const oldVel = body.velocity; const newVel = { x: oldVel.x * cos - oldVel.y * sin, y: oldVel.x * sin + oldVel.y * cos }; const newAngle = body.angle + angleChange; this.Body.setPosition(body, newPos); this.Body.setVelocity(body, newVel); this.Body.setAngle(body, newAngle); }); this.worldAngle += angleChange; this.updateVisualsAndGravity(); },
            handleSliderInput(e, key) {
                const value = parseFloat(e.target.value);
                this.dom.values[key].textContent = value.toFixed(key === 'restitution' ? 2 : 1);
                switch (key) {
                    case 'gravity': this.SETTINGS.gravityScale = value; this.updateVisualsAndGravity(); break;
                    case 'timescale': this.SETTINGS.timeScale = value; if (!this.isPaused) { this.engine.timing.timeScale = this.SETTINGS.timeScale; } break;
                    case 'restitution': this.SETTINGS.restitution = value; this.Composite.allBodies(this.world).forEach(body => { if (!body.isStatic && body.label === 'userBody') { body.restitution = this.SETTINGS.restitution; } }); break;
                }
            },
            initEvents() {
                this.Events.on(this.engine, 'beforeUpdate', () => {
                    const bodies = this.Composite.allBodies(this.world);
                    const attractors = bodies.filter(b => b.isAttractor);
                    const vortices = bodies.filter(b => b.isVortex);
                    const gravityZones = bodies.filter(b => b.isGravityZone);
                    for (const body of bodies) {
                        if (body.isStatic || body.isSensor) { if (body.teleportCooldown > 0) body.teleportCooldown--; continue; }
                        if (body.motorDirection) this.Body.setAngularVelocity(body, this.SETTINGS.motorSpeed * body.motorDirection);
                        if (body.isThruster && body.isThrusterActive) { const forceMagnitude = body.thrustForce * this.SETTINGS.timeScale; const force = { x: Math.sin(body.angle) * forceMagnitude, y: -Math.cos(body.angle) * forceMagnitude }; this.Body.applyForce(body, body.position, force); }
                        attractors.forEach(attractor => { if (body === attractor) return; const vec = {x: attractor.position.x - body.position.x, y: attractor.position.y - body.position.y}; const distSq = vec.x * vec.x + vec.y * vec.y; if (distSq > 1 && distSq < attractor.attractionRadius * attractor.attractionRadius) { const dist = Math.sqrt(distSq); const forceMag = attractor.attractionForce * body.mass; const force = { x: (vec.x / dist) * forceMag, y: (vec.y / dist) * forceMag }; this.Body.applyForce(body, body.position, force); }});
                        vortices.forEach(vortex => { if (body === vortex) return; const vec = {x: vortex.position.x - body.position.x, y: vortex.position.y - body.position.y}; const distSq = vec.x * vec.x + vec.y * vec.y; if (distSq > 1 && distSq < vortex.vortexRadius * vortex.vortexRadius) { const dist = Math.sqrt(distSq); const inwardForceMag = vortex.vortexInwardForce * body.mass; const inwardForce = { x: (vec.x / dist) * inwardForceMag, y: (vec.y / dist) * inwardForceMag }; const tangentialForce = { x: -vec.y / dist * vortex.vortexTangentialForce * body.mass * dist, y: vec.x / dist * vortex.vortexTangentialForce * body.mass * dist }; this.Body.applyForce(body, body.position, inwardForce); this.Body.applyForce(body, body.position, tangentialForce); }});
                        let inZone = false;
                        for (const zone of gravityZones) { if (this.Bounds.contains(zone.bounds, body.position)) { inZone = true; break; } }
                        if (inZone) { const antiGravity = { x: -this.engine.gravity.x * this.engine.gravity.scale * body.mass, y: -this.engine.gravity.y * this.engine.gravity.scale * body.mass }; this.Body.applyForce(body, body.position, antiGravity); const upwardForce = { x: 0, y: -0.002 * body.mass }; this.Body.applyForce(body, body.position, upwardForce); }
                        if (body.teleportCooldown > 0) body.teleportCooldown--;
                    }
                });
                this.Events.on(this.render, 'afterRender', (event) => { const context = event.source.context; if (this.pushStartPos && this.pushEndPos) { context.beginPath(); context.moveTo(this.pushStartPos.x, this.pushStartPos.y); context.lineTo(this.pushEndPos.x, this.pushEndPos.y); context.strokeStyle = 'rgba(255, 171, 64, 0.8)'; context.lineWidth = 3; context.stroke(); } if (this.isDrawing && this.penPoints.length > 1) { context.beginPath(); context.moveTo(this.penPoints[0].x, this.penPoints[0].y); for (let i = 1; i < this.penPoints.length; i++) { context.lineTo(this.penPoints[i].x, this.penPoints[i].y); } context.strokeStyle = 'rgba(3, 169, 244, 0.7)'; context.lineWidth = 4; context.stroke(); } });
                this.Events.on(this.engine, 'collisionStart', (event) => { event.pairs.forEach(pair => { const checkTeleport = (teleporter, otherBody) => { if (otherBody.isSensor || otherBody.isStatic || otherBody.teleportCooldown > 0 || !teleporter.linkedTeleporter) return; otherBody.teleportCooldown = 20; teleporter.linkedTeleporter.teleportCooldown = 20; const dest = teleporter.linkedTeleporter.position; const vel = otherBody.velocity; const angVel = otherBody.angularVelocity; this.Body.setPosition(otherBody, { x: dest.x, y: dest.y }); this.Body.setVelocity(otherBody, vel); this.Body.setAngularVelocity(otherBody, angVel); }; if (pair.bodyA.isTeleporter) checkTeleport(pair.bodyA, pair.bodyB); if (pair.bodyB.isTeleporter) checkTeleport(pair.bodyB, pair.bodyA); }); });
                this.render.canvas.addEventListener('mousedown', (event) => {
                    if (event.button !== 0) return;
                    const mousePos = this.mouseConstraint.mouse.position; const body = this.getBodyAt(mousePos);
                    switch (this.CONFIG.currentTool) {
                        case 'add': if (!body) this.createShape(mousePos.x, mousePos.y); break;
                        case 'remove': if(body) this.removeBodyAndConstraints(body); break;
                        case 'pin': this.togglePin(body); break;
                        case 'motor': this.toggleMotor(body, 1); break;
                        case 'link': this.handleLinkTool(body); break;
                        case 'push': if (body && !body.isStatic) { this.pushStartPos = { ...mousePos }; this.pushEndPos = { ...mousePos }; this.pushTargetBody = body; } break;
                        case 'pen': this.isDrawing = true; this.penPoints = [{...mousePos}]; break;
                        case 'eraser': if (body && body.shapeType === 'penWall') { this.removeBodyAndConstraints(body); } break;
                        case 'tuner': if (body && !body.isStatic) { body.restitution = Math.min(1.5, body.restitution + 0.1); this.showToast(`å¼¹åŠ› (Bounciness): ${body.restitution.toFixed(2)}`, 'info', 1000); } break;
                    }
                });
                window.addEventListener('mousemove', (event) => { const mousePos = this.mouseConstraint.mouse.position; if (this.pushStartPos) this.pushEndPos = mousePos; if (this.isDrawing) this.penPoints.push({...mousePos}); });
                window.addEventListener('mouseup', (event) => {
                    if (event.button !== 0) return;
                    if (this.pushStartPos && this.pushTargetBody) { const forceVector = { x: (this.pushStartPos.x - this.pushEndPos.x) * 0.0005, y: (this.pushStartPos.y - this.pushEndPos.y) * 0.0005 }; this.Body.applyForce(this.pushTargetBody, this.pushStartPos, forceVector); this.pushStartPos = this.pushEndPos = this.pushTargetBody = null; }
                    if (this.isDrawing) {
                        this.isDrawing = false;
                        if (this.penPoints.length > 1) {
                            const simplifiedPoints = this.Vertices.removeCollinear(this.Vertices.create(this.penPoints));
                            if (simplifiedPoints.length > 1) {
                                const wallSegments = [];
                                for (let i = 0; i < simplifiedPoints.length - 1; i++) {
                                    const startPoint = simplifiedPoints[i];
                                    const endPoint = simplifiedPoints[i+1];
                                    const dx = endPoint.x - startPoint.x;
                                    const dy = endPoint.y - startPoint.y;
                                    const distance = Math.hypot(dx, dy);
                                    if (distance < 2) continue;
                                    const angle = Math.atan2(dy, dx);
                                    const center = { x: startPoint.x + dx / 2, y: startPoint.y + dy / 2 };
                                    const wallThickness = 5;
                                    const segment = this.Bodies.rectangle(center.x, center.y, distance, wallThickness, { isStatic: true, angle: angle, label: 'userBody', shapeType: 'penWall', render: { fillStyle: '#03a9f4' }, friction: 0.7, restitution: 0.5 });
                                    wallSegments.push(segment);
                                }
                                if(wallSegments.length > 0) {
                                    this.Composite.add(this.world, wallSegments);
                                    this.showToast('å¢™å£å·²ç»˜åˆ¶!', 'success');
                                }
                            }
                        }
                        this.penPoints = [];
                    }
                });
                this.render.canvas.addEventListener('contextmenu', e => {
                    e.preventDefault();
                    const mousePos = this.mouseConstraint.mouse.position; const body = this.getBodyAt(mousePos);
                    if (this.CONFIG.currentTool === 'motor') { this.toggleMotor(body, -1); return; }
                    if (this.CONFIG.currentTool === 'tuner' && body && !body.isStatic) { body.restitution = Math.max(0, body.restitution - 0.1); this.showToast(`å¼¹åŠ› (Bounciness): ${body.restitution.toFixed(2)}`, 'info', 1000); return; }
                    if (body && body.isThruster) { this.toggleThruster(body); return; }
                    if (!body && this.CONFIG.currentTool === 'add' && this.CONFIG.currentShape === 'platform') { this.createShape(mousePos.x, mousePos.y, 'platform', { angle: Math.PI / 2 }); return; }
                    if (this.linkFirstBody) { this.linkFirstBody = null; this.showToast('å·²å–æ¶ˆè¿æ¥æ“ä½œ', 'info'); }
                    if (this.pushStartPos) { this.pushStartPos = null; this.showToast('å·²å–æ¶ˆæ¨åŠ¨æ“ä½œ', 'info'); }
                    if (this.isDrawing) { this.isDrawing = false; this.penPoints = []; this.showToast('å·²å–æ¶ˆç»˜åˆ¶', 'info'); }
                    if (this.teleporterLinkTarget) { this.Composite.remove(this.world, this.teleporterLinkTarget); this.teleporterLinkTarget = null; this.showToast('å·²å–æ¶ˆä¼ é€é—¨é…å¯¹', 'info'); }
                });
                this.render.canvas.addEventListener('wheel', e => {
                    if (this.CONFIG.currentTool !== 'scale') return;
                    e.preventDefault();
                    const mousePos = this.mouseConstraint.mouse.position;
                    const body = this.getBodyAt(mousePos);
                    if (body && !body.isStatic) {
                        const scaleFactor = e.deltaY < 0 ? 1.05 : 0.95;
                        this.Body.scale(body, scaleFactor, scaleFactor);
                        this.Body.setMass(body, body.mass * scaleFactor * scaleFactor);
                    }
                }, { passive: false });
                window.addEventListener('keydown', e => { if (e.target.matches('input, select')) return; const mousePos = this.mouseConstraint.mouse.position; const bodyUnderMouse = this.getBodyAt(mousePos); let angleChange = 0; switch (e.key.toLowerCase()) { case 'e': case 'arrowright': angleChange = e.shiftKey ? Math.PI / 2 : 0.05; break; case 'q': case 'arrowleft': angleChange = -(e.shiftKey ? Math.PI / 2 : 0.05); break; case 'c': e.preventDefault(); this.clearAll(); break; case 'r': e.preventDefault(); this.rotateWorld(-this.worldAngle); this.showToast('ä¸–ç•Œæ—‹è½¬å·²é‡ç½®', 'info'); break; case ' ': e.preventDefault(); this.isPaused = !this.isPaused; this.engine.timing.timeScale = this.isPaused ? 0 : this.SETTINGS.timeScale; this.showToast(this.isPaused ? 'å·²æš‚åœ' : 'å·²ç»§ç»­', 'info'); break; case 'd': if (bodyUnderMouse) { e.preventDefault(); this.removeBodyAndConstraints(bodyUnderMouse); this.showToast('ç‰©ä½“å·²åˆ é™¤!', 'info'); } break; case 'p': if (this.mouseConstraint.body && !this.mouseConstraint.body.isStatic) { e.preventDefault(); this.togglePin(this.mouseConstraint.body); this.mouseConstraint.body = null; } break; case 'escape': this.dom.settingsPanel.style.display = 'none'; this.dom.helpPanelOverlay.style.display = 'none'; break; } if (angleChange) { e.preventDefault(); this.rotateWorld(angleChange); } });
            },

            // *** FINAL FIX: The robust and correct getBodyAt function ***
            getBodyAt(position) {
                const bodiesUnderMouse = this.Query.point(this.Composite.allBodies(this.world), position);
                
                let targetBody = null;
                for (const body of bodiesUnderMouse) {
                    // Priority 1: If it's a part of a soft body, we want the whole composite
                    if (body.parent && body.parent.shapeType === 'soft') {
                        targetBody = body.parent;
                        break; // Found the most important target, no need to check others
                    }
                    
                    // Priority 2: If it's a user-created body (shape or wall segment)
                    if (body.label === 'userBody') {
                        // If we haven't found a target yet, or this new one is smaller, it's a better candidate
                        if (!targetBody || body.area < targetBody.area) {
                            targetBody = body;
                        }
                    }
                }
                return targetBody;
            },

            handleLinkTool(body) { if(body && body.type === 'body') { if(!this.linkFirstBody) { this.linkFirstBody = body; this.showToast('å·²é€‰æ‹©ç¬¬ä¸€ä¸ªç‰©ä½“ï¼Œè¯·é€‰æ‹©ç¬¬äºŒä¸ª', 'info'); } else if(this.linkFirstBody !== body) { const c = this.Constraint.create({bodyA:this.linkFirstBody, bodyB:body, stiffness:0.1, label:'userConstraint', render: { strokeStyle: '#fff', lineWidth: 2 }}); this.Composite.add(this.world, c); this.linkFirstBody = null; } else { this.linkFirstBody = null; this.showToast('å·²å–æ¶ˆè¿æ¥æ“ä½œ', 'info'); } } },
            togglePin(body) { if (!body) return; if (body.shapeType === 'soft') { const newStaticState = !body.bodies[0].isStatic; body.bodies.forEach(p => { this.Body.setStatic(p, newStaticState); p.motorDirection = 0; }); this.showToast(`æŸ”æ€§ä½“å·²${newStaticState ? 'å›ºå®š' : 'å–æ¶ˆå›ºå®š'}!`, 'info'); } else if (body.type === 'body') { const newStaticState = !body.isStatic; this.Body.setStatic(body, newStaticState); if (newStaticState) body.motorDirection = 0; this.showToast(`ç‰©ä½“å·²${newStaticState ? 'å›ºå®š' : 'å–æ¶ˆå›ºå®š'}!`, 'info'); } },
            toggleMotor(body, direction) { if (body && body.type === 'body' && !body.isStatic) { body.motorDirection = (body.motorDirection === direction) ? 0 : direction; } },
            toggleThruster(body) { if (!body || !body.isThruster || body.isStatic) return; body.isThrusterActive = !body.isThrusterActive; this.updateThrusterVisual(body); this.showToast(`æ¨è¿›å™¨å·²${body.isThrusterActive ? 'å¼€å¯' : 'å…³é—­'}`, 'info'); },
            updateThrusterVisual(body) { if (!body || !body.isThruster) return; body.render.fillStyle = body.isThrusterActive ? '#ffab40' : '#607d8b'; body.render.strokeStyle = body.isThrusterActive ? '#fff' : '#cfd8dc'; },
            showToast(message, type = 'info', duration = 3000) { const toast = document.createElement('div'); toast.className = `toast ${type}`; toast.textContent = message; this.dom.toastContainer.appendChild(toast); setTimeout(() => { toast.style.animation = 'slideOut 0.5s forwards'; toast.addEventListener('animationend', () => toast.remove()); }, duration); }
        };

        PhysicsLab.init();
        window.lab = PhysicsLab;
    });
    </script>
    </body>
</html>